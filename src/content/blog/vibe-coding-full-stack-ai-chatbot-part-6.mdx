---
title: "Vibe Coding a Full-Stack AI Chatbot Platform (Part 6): End-to-End Type Safety with tRPC"
description: "Define tRPC routers inside NestJS, export AppRouter types, and consume them from React with TanStack Query."
pubDate: 2026-01-30
tags: ["tutorial", "ai", "chatbot", "llm", "full-stack", "cursor", "typescript", "react", "nestjs", "trpc", "tanstack-query", "zod", "better-auth"]
heroImage: "/images/vibe-coding-full-stack-ai-chatbot-part-6-hero-image.jpg"
---

This is Part 6 of the tutorial series. If you haven’t read the earlier parts, you can start with [Part 1: Introduction](https://blog.sneyderangulo.com/blog/vibe-coding-full-stack-ai-chatbot-part-1), or read the previous part [Part 5: Authentication with Better Auth](https://blog.sneyderangulo.com/blog/vibe-coding-full-stack-ai-chatbot-part-5).

In Part 5, we set up authentication with Better Auth (email/password + Google OAuth). Now we need the wire that will allow our React frontend to call the NestJS backend and get the data we need.

As discussed in Part 2, tRPC is the perfect tool to help us achieve our goal of having end-to-end type safety between our React frontend and NestJS backend.

## Goal for this part

By the end of this part we’ll have:

- tRPC **routers and procedures defined in `apps/api`** (Nest owns the API surface)
- A small shared `@ai-chatbot/trpc` **helpers package** (router + public/protected procedures)
- `AppRouter` **types exported to the frontend** (via `@ai-chatbot/api/trpc`)
- A `/api/trpc` endpoint mounted in **NestJS**
- A tRPC client wired into **React + TanStack Query**
- Our first **protected procedures**: `chat.create` and `chat.list` (backed by Prisma)

---

## Step 1: Add a minimal `Chat` model (will be used to store our chats and create our first protected procedures)

Goal: Add a `Chat` table so `chat.create` and `chat.list` can persist data.

Prompt:
> Update my Prisma schema to add a `Chat` model. Requirements:
> - Use UUIDv7 for chat IDs
> - Follow my mapping conventions (`@@map` for snake_case table names, `@map` for column names)
> - Use PostgreSQL `timestamptz` (`@db.Timestamptz`) for timestamps
> - Chat belongs to a User (one user has many chats)
> - Add an index on `user_id`
>
> Keep it minimal: id, userId, title, createdAt, updatedAt.

Model: GPT-5.2 (high reasoning)

Summary:
- Added a `Chat` model under `packages/db/prisma/schema.prisma`

Adjustments:
- This was pretty simple, so no adjustments were needed.
---

## Step 2: Create a shared tRPC helpers package (`packages/trpc`)

Goal: This package is for the shared, typed tRPC setup, so we can reuse it in other backend packages later on if needed.

Prompt:
> Create a new buildable workspace package at `packages/trpc` called `@ai-chatbot/trpc`.
> Requirements:
> - Compile to `dist/` (CommonJS is fine, consistent with our other backend packages)
> - Export `router`, `publicProcedure`, and `protectedProcedure`
> - Export `TrpcContext` and `ProtectedContext`
> - `protectedProcedure` must throw `UNAUTHORIZED` if there is no authenticated user in context

Model: GPT-5.2 (high reasoning)

Summary:
- Created a buildable `@ai-chatbot/trpc` package that centralizes our tRPC + auth middleware
- Created the directory structure for `packages/trpc` with `context.ts`, `trpc.ts`, and `index.ts`.
- Defined `AuthUser`, `TrpcContext`, and `ProtectedContext` types which will be used to create the context for our tRPC procedures and will contain the `db` and `user` instances.
- Initialized tRPC and defined `router`, `publicProcedure`, and `protectedProcedure` with auth middleware.

---

## Step 3: Define routers in NestJS (apps/api) and mount `/api/trpc`

Goal:
- Define routers/procedures in `apps/api` (**Nest owns the API surface**)
- Mount tRPC at `/api/trpc`
- Create a context per request that includes:
  - `db` (Prisma client from our `db` package)
  - `user` (from Better Auth cookies)
- Export `AppRouter` types for the frontend from `@ai-chatbot/api/trpc`

Prompt:
> In apps/api, create a minimal tRPC router with:
> - `chat.create` and `chat.list` as protected procedures (Prisma-backed)
> - a `createContext` that injects `db` and resolves `user` from Better Auth cookies
> Then mount it at `/api/trpc` in `main.ts`.
>
> Finally, export `AppRouter` types from the API package so the web app can import them.

Model: GPT-5.2 (high reasoning)

Summary:
- Added chat procedures + app router inside `apps/api/src/trpc`
- Added a typed `createContext`
- Mounted `createExpressMiddleware` in `main.ts`
- Exported `AppRouter` types via `@ai-chatbot/api/trpc`

---

## Step 4: Create the typed tRPC client in React (TanStack Query)

Goal: Make the web app call `/api/trpc` with:
- end-to-end types from `AppRouter`
- cookies enabled (so Better Auth sessions work)

Prompt:
> In apps/web, set up tRPC + TanStack Query.
> Requirements:
> - Add `@ai-chatbot/api` as a workspace devDependency (so TS can import `AppRouter`)
> - Create a `trpc` helper typed with `AppRouter` from `@ai-chatbot/api/trpc`
> - Create a QueryClient
> - Use `httpBatchLink` pointing at `${VITE_API_URL}/api/trpc`
> - Ensure cookies are included (`credentials: "include"`)
> - Wrap the app in providers in `main.tsx`

Model: GPT-5.2 High Reasoning

Summary:
- Added `src/lib/trpc.ts`
- Updated `src/main.tsx` to include QueryClientProvider + trpc.Provider

---

## Step 5: Call our first protected procedures from the UI

Goal: When a user is signed in, show a tiny “Chats” panel:
- list chats
- create a new chat
- invalidate the list

Prompt:
> Create a `ChatsPanel` component that:
> - calls `trpc.chat.list.useQuery()`
> - calls `trpc.chat.create.useMutation()`
> - invalidates `chat.list` on success
> - shows loading and error states
> - uses the existing `Button` styling
> - plug it into the authenticated branch of `App.tsx`

Model: Claude Opus 4.5

Summary:
- Implemented `ChatsPanel` component to list chats and create new ones using tRPC hooks (`trpc.chat.list.useQuery`, `trpc.chat.create.useMutation`).

At this point we should be able to:
- Log in / Sign up
- Once logged in, see an empty chat list
- Create a chat
- See it appear immediately in the list

---

## Testing checklist

1. Start the database:

Run `docker compose up -d`

2. Start apps:

Run `pnpm dev`

3. In the browser:
- Sign in
- Click “New chat”
- Refresh the page (list should still show, because data is persisted)

---

## Code Quality Standards

To maintain consistent code quality and development practices across the codebase, I've added Cursor Rules that enforce our standards:

- **Quality Checks** (`.cursor/rules/quality-checks.mdc`): Defines required checks that must run after any code changes, including formatting, linting, and TypeScript type checking
- **Prisma Schema Conventions** (`.cursor/rules/prisma-schema-conventions.mdc`): Ensures consistent Prisma schema patterns, including UUIDv7 IDs, PostgreSQL timestamptz types, and proper snake_case mapping

These rules help maintain the high-quality, maintainable code standards I've established throughout the tutorial series so that the codebase is consistent and easy to maintain.

I also asked the AI to do a code review of the codebase, fixed minor issues it found and also did:
- Add validation to env variables with zod in the `@ai-chatbot/api` package.
- Add basic rate limiting to the `/api/auth` and `/api/trpc` endpoints with `express-rate-limit`.
- Improve CORS configuration in the `@ai-chatbot/api` package.
- Add helmet to the `@ai-chatbot/api` package with a basic configuration.

---

## Next steps

We can create chats, but we still don’t have an actual “chatbot”.

In Part 7, we’ll build the core chat experience:
- Message model + persistence
- A chat page UI
- Sending a message to the backend and saving it

Then we can finally plug in an LLM provider and start streaming responses.

> **Repository State**: The current state of the codebase described in this article is available in the [`feat/trpc-setup`](https://github.com/Sneyder2328/ai-chatbot/tree/feat/trpc-setup) branch on GitHub.
