---
title: "Why Your App is Logging the Wrong IP Address (And How to Fix It)"
description: "A follow-up to my IP addresses article - discovering why my server logs were full of the same internal IP and how to properly capture client IPs behind proxies and load balancers."
pubDate: 2024-11-20
tags: ["networking", "devops", "backend", "security", "debugging"]
---

Hey guys, it's me again ‚Äî back with another story about IP addresses and networking fun. üòÑ This time I want to share a debugging adventure that taught me something important about how web traffic actually flows in production.

## The Mystery of the Identical IPs

After writing my last article about finally understanding IP addresses, I felt pretty good about myself. I knew about static vs dynamic IPs, NAT, IPv4 vs IPv6 ‚Äî the whole deal.

Then I deployed a new feature to production: **rate limiting by IP address**.

The idea was simple: limit each user to 100 API requests per minute based on their IP. Easy, right?

Wrong. üòÖ

Within hours, I started getting reports that *everyone* was being rate limited. I checked the logs, and my jaw dropped. Every single request was coming from the same IP address:

```
10.0.0.1 - - [20/Nov/2024:10:15:32] "GET /api/users" 200
10.0.0.1 - - [20/Nov/2024:10:15:33] "POST /api/orders" 201
10.0.0.1 - - [20/Nov/2024:10:15:33] "GET /api/products" 200
10.0.0.1 - - [20/Nov/2024:10:15:34] "GET /api/users" 200
```

Thousands of requests, all from `10.0.0.1`. That's not a real user ‚Äî that's a **private IP address**. What was going on?

---

## The Culprit: Reverse Proxies and Load Balancers

Here's what I didn't fully understand about modern web architecture: **your application almost never talks directly to the user**.

In most production setups, the traffic flow looks like this:

```
User (203.0.113.45) 
    ‚Üí Load Balancer (AWS ALB)
        ‚Üí Reverse Proxy (Nginx)
            ‚Üí Your Application
```

Each hop in this chain establishes a new TCP connection. So when your app calls something like `request.ip` or `request.connection.remoteAddress`, you're not getting the user's IP ‚Äî you're getting the IP of the **last proxy** that connected to you.

In my case, that was `10.0.0.1` ‚Äî the internal IP of our Nginx container. ü§¶‚Äç‚ôÇÔ∏è

---

## The Solution: X-Forwarded-For Header

Thankfully, there's a standard solution. When a proxy forwards a request, it's supposed to add the original client's IP to a special header called `X-Forwarded-For`.

The header accumulates IPs as the request passes through each proxy:

```
X-Forwarded-For: 203.0.113.45, 70.41.3.18, 10.0.0.1
```

Reading left to right:
1. `203.0.113.45` ‚Äî The original client IP (what you usually want)
2. `70.41.3.18` ‚Äî First proxy (maybe a CDN like Cloudflare)
3. `10.0.0.1` ‚Äî Last proxy before your app

So the fix is simple: **read the first IP from the `X-Forwarded-For` header** instead of using the connection's remote address.

---

## Implementation Examples

Here's how to properly get the client IP in different frameworks:

### Node.js / Express

```javascript
function getClientIp(req) {
  // Check X-Forwarded-For header first
  const forwarded = req.headers['x-forwarded-for'];
  if (forwarded) {
    // Get the first IP in the chain (original client)
    return forwarded.split(',')[0].trim();
  }
  // Fallback to direct connection IP
  return req.connection.remoteAddress;
}
```

Or use a trusted library like `request-ip`:

```javascript
import requestIp from 'request-ip';

app.get('/api/data', (req, res) => {
  const clientIp = requestIp.getClientIp(req);
  console.log('Client IP:', clientIp);
});
```

### Python / Flask

```python
from flask import request

def get_client_ip():
    # Check X-Forwarded-For header
    if request.headers.get('X-Forwarded-For'):
        # First IP is the original client
        return request.headers['X-Forwarded-For'].split(',')[0].strip()
    return request.remote_addr
```

### Python / Django

```python
def get_client_ip(request):
    x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
    if x_forwarded_for:
        return x_forwarded_for.split(',')[0].strip()
    return request.META.get('REMOTE_ADDR')
```

---

## ‚ö†Ô∏è Security Warning: Trust, But Verify

Here's the catch: **anyone can send an `X-Forwarded-For` header**.

A malicious user could send a request like:

```
curl -H "X-Forwarded-For: 1.2.3.4" https://yourapi.com/endpoint
```

If you blindly trust this header, they could:
- Bypass your rate limiting
- Spoof their location for geo-restricted content
- Frame someone else for malicious activity

### The Fix: Configure Trusted Proxies

You need to tell your application which proxies to trust. Only accept `X-Forwarded-For` values that come from your known infrastructure.

**Express.js:**
```javascript
// Trust first proxy (load balancer)
app.set('trust proxy', 1);

// Or trust specific IPs
app.set('trust proxy', ['loopback', '10.0.0.0/8']);
```

**Nginx** (set the header correctly):
```nginx
location / {
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_pass http://backend;
}
```

**AWS ALB** automatically sets `X-Forwarded-For` and you can trust it since it's your infrastructure.

---

## Other Useful Headers

While we're at it, here are other headers proxies commonly set:

| Header | Purpose |
|--------|---------|
| `X-Forwarded-For` | Chain of client and proxy IPs |
| `X-Real-IP` | Single original client IP (Nginx) |
| `X-Forwarded-Proto` | Original protocol (http/https) |
| `X-Forwarded-Host` | Original host header |
| `CF-Connecting-IP` | Client IP (Cloudflare specific) |
| `True-Client-IP` | Client IP (Akamai/Cloudflare) |

---

## Lessons Learned

1. **Your app is rarely the first point of contact** ‚Äî There's almost always a proxy, load balancer, or CDN in front of it.

2. **`request.ip` lies** ‚Äî It gives you the last hop, not the original client.

3. **Headers can be spoofed** ‚Äî Always configure trusted proxies in production.

4. **Test with real infrastructure** ‚Äî This bug never showed up in local development because there was no proxy in the way.

After fixing my code to properly read `X-Forwarded-For`, the rate limiting worked perfectly. Different users got their own limits, and my logs finally showed real, diverse IP addresses from around the world.

Another networking lesson learned the hard way! üåê

---

*This is a follow-up to my previous article: [I've Been a Developer for over 8 Years, and I Just Actually Understood IP Addresses](/blog/understanding-ip-addresses)*

